/*
 * DO NOT EDIT THIS FILE. Generated by checkmk.
 * Edit the original source file "backend/test/test.ts" instead.
 */

#include <check.h>

#line 1 "backend/test/test.ts"
#include <stdio.h>
#include "../src/backend.h"

// Remove
START_TEST(test_create_cell)
{
#line 6
    PointList* snake = create_cell(2, 3);
    fail_unless(snake->x == 2);
    fail_unless(snake->y == 3);

}
END_TEST

START_TEST(test_create_board)
{
#line 11
    PointList* snake = create_cell(0, 0);
    Board* board = create_board(snake, NULL, 2, 3);
    fail_unless(board->xmax == 2);
    fail_unless(board->ymax == 3);
    fail_unless(board->snake != NULL);
    fail_unless(board->snake->x == 0);



}
END_TEST

START_TEST(test_move_snake_length_1)
{
#line 21
    PointList* snake = create_cell(0, 0);
    Board* board = create_board(snake, NULL, 2, 2);
    fail_unless(move_snake(board, LEFT) == FAILURE);
    fail_unless(move_snake(board, UP) == FAILURE);
    fail_unless(move_snake(board, DOWN) == SUCCESS);
    fail_unless(move_snake(board, DOWN) == FAILURE);

}
END_TEST

START_TEST(test_move_snake_backwards)
{
#line 29
    PointList* snake = create_cell(2, 2);
    snake->next = create_cell(2, 3);
    Board* board = create_board(snake, NULL, 2, 2);
    move_snake(board, DOWN);
    fail_unless(board->snake->x == 2);
    fail_unless(board->snake->y == 2);

}
END_TEST

START_TEST(test_move_snake_collision)
{
#line 37
    PointList* snake = create_cell(2, 2);
    snake->next = create_cell(2, 3);
    snake->next->next = create_cell(3, 3);
    snake->next->next->next = create_cell(3, 2);
    Board* board = create_board(snake, NULL, 4, 4);
    fail_unless(move_snake(board, RIGHT) == FAILURE);

}
END_TEST

START_TEST(test_move_snake_down)
{
#line 45
    PointList* snake = create_cell(2, 2);
    Board* board = create_board(snake, NULL, 4, 4);
    move_snake(board, DOWN);
    fail_unless(board->snake->x == 2);
    fail_unless(board->snake->y == 3);


}
END_TEST

START_TEST(test_move_snake_normally)
{
#line 53
    PointList* snake = create_cell(2, 2);
    snake->next = create_cell(2, 3);
    Board* board = create_board(snake, NULL, 4, 4);
    move_snake(board, UP);
    fail_unless(board->snake->x == 2);
    fail_unless(board->snake->y == 1);
    fail_unless(board->snake->next->x == 2);
    fail_unless(board->snake->next->y == 2);
    fail_unless(board->snake->next->next == NULL);

// Remove
}
END_TEST

START_TEST(test_next_move_corner)
{
#line 65
    PointList* snake = create_cell(0, 0);
    Board* board = create_board(snake, NULL, 2, 2);
    fail_unless(next_move(board, UP) == NULL);
    fail_unless(next_move(board, LEFT) == NULL);
    fail_unless(next_move(board, DOWN) != NULL);
    fail_unless(next_move(board, RIGHT) != NULL);

// Remove
}
END_TEST

START_TEST(test_next_move_bottom)
{
#line 74
    PointList* snake = create_cell(0, 1);
    Board* board = create_board(snake, NULL, 2, 2);
    fail_unless(next_move(board, LEFT) == NULL);
    fail_unless(next_move(board, DOWN) == NULL);
    fail_unless(next_move(board, UP) != NULL);
    fail_unless(next_move(board, RIGHT) != NULL);

// Remove
}
END_TEST

START_TEST(test_next_move_left)
{
#line 83
    PointList* snake = create_cell(1, 2);
    Board* board = create_board(snake, NULL, 4, 4);
    PointList* moved = next_move(board, LEFT);
    fail_unless(moved->x == 0);
    fail_unless(moved->y == 2);

// Remove
}
END_TEST

START_TEST(test_next_move_up)
{
#line 91
    PointList* snake = create_cell(2, 2);
    Board* board = create_board(snake, NULL, 4, 4);
    PointList* moved = next_move(board, UP);
    fail_unless(moved->x == 2);
    fail_unless(moved->y == 1);

// Remove
}
END_TEST

START_TEST(test_create_random_cell)
{
#line 99
    PointList* cell1 = create_random_cell(20, 10);
    PointList* cell2 = create_random_cell(20, 10);
    fail_unless(!(cell1->x == cell2->x && cell1->y == cell2->y));
    fail_unless(cell1->x < 20);
    fail_unless(cell2->x < 20);
    fail_unless(cell1->y < 10);
    fail_unless(cell2->y < 10);

// Remove
}
END_TEST

START_TEST(test_list_contains_true)
{
#line 109
    PointList* cell = create_cell(1, 2);
    PointList* list = create_cell(2, 2);
    list->next = create_cell(1, 2);
    fail_unless(list_contains(cell, list));

// Remove
}
END_TEST

START_TEST(test_list_contains_false)
{
#line 116
    PointList* cell = create_cell(4, 2);
    PointList* list = create_cell(2, 2);
    list->next = create_cell(1, 2);
    fail_unless(!list_contains(cell, list));

}
END_TEST

START_TEST(test_add_new_food_null)
{
#line 122
    PointList* snake = create_cell(4, 2);
    snake->next = create_cell(4,3);
    Board* board = create_board(snake, NULL, 20, 10);
    add_new_food(board);
    PointList* foods = board->foods;
    fail_unless(foods != NULL);
    fail_unless(foods->next == NULL);
    fail_unless(!list_contains(foods, snake));

}
END_TEST

START_TEST(test_add_new_food)
{
#line 132
    PointList* snake = create_cell(4, 2);
    snake->next = create_cell(4,3);
    PointList* foods = create_cell(3, 3);
    Board* board = create_board(snake, foods, 20, 10);
    add_new_food(board);
    fail_unless(board->foods->next != NULL);
    fail_unless(board->foods->next->next == NULL);

}
END_TEST

START_TEST(test_move_snake_with_food)
{
#line 141
    PointList* snake = create_cell(1, 2);
    PointList* foods = create_cell(2, 2);
    Board* board = create_board(snake, foods, 10, 10);
    move_snake(board, RIGHT);
    fail_unless(board->snake->x == 2);
    fail_unless(board->snake->y == 2);
    fail_unless(board->snake->next != NULL);
    fail_unless(board->snake->next->x == 1);
    fail_unless(board->snake->next->y == 2);

    fail_unless(board->foods->x != 2 || board->foods->y != 2);

// Remove
}
END_TEST

START_TEST(test_remove_from_list_true)
{
#line 155
    PointList* cell = create_cell(1, 2);
    PointList* list = create_cell(2, 2);
    list->next = create_cell(1, 2);
    fail_unless(remove_from_list(cell, &list));

// Remove
}
END_TEST

START_TEST(test_remove_from_list_false)
{
#line 162
    PointList* cell = create_cell(3, 2);
    PointList* list = create_cell(2, 2);
    list->next = create_cell(1, 2);
    fail_unless(!remove_from_list(cell, &list));

}
END_TEST

int main(void)
{
    Suite *s1 = suite_create("Core");
    TCase *tc1_1 = tcase_create("Core");
    SRunner *sr = srunner_create(s1);
    int nf;

    suite_add_tcase(s1, tc1_1);
    tcase_add_test(tc1_1, test_create_cell);
    tcase_add_test(tc1_1, test_create_board);
    tcase_add_test(tc1_1, test_move_snake_length_1);
    tcase_add_test(tc1_1, test_move_snake_backwards);
    tcase_add_test(tc1_1, test_move_snake_collision);
    tcase_add_test(tc1_1, test_move_snake_down);
    tcase_add_test(tc1_1, test_move_snake_normally);
    tcase_add_test(tc1_1, test_next_move_corner);
    tcase_add_test(tc1_1, test_next_move_bottom);
    tcase_add_test(tc1_1, test_next_move_left);
    tcase_add_test(tc1_1, test_next_move_up);
    tcase_add_test(tc1_1, test_create_random_cell);
    tcase_add_test(tc1_1, test_list_contains_true);
    tcase_add_test(tc1_1, test_list_contains_false);
    tcase_add_test(tc1_1, test_add_new_food_null);
    tcase_add_test(tc1_1, test_add_new_food);
    tcase_add_test(tc1_1, test_move_snake_with_food);
    tcase_add_test(tc1_1, test_remove_from_list_true);
    tcase_add_test(tc1_1, test_remove_from_list_false);

    srunner_run_all(sr, CK_ENV);
    nf = srunner_ntests_failed(sr);
    srunner_free(sr);

    return nf == 0 ? 0 : 1;
}
